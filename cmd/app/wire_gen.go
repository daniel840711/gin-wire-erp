// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"go.uber.org/zap"
	"interchange/config"
	"interchange/internal/command"
	command2 "interchange/internal/command/handler"
	"interchange/internal/cron"
	"interchange/internal/database/client"
	"interchange/internal/database/fluentd/repository"
	repository2 "interchange/internal/database/mongodb/repository"
	repository3 "interchange/internal/database/redis/repository"
	"interchange/internal/handler"
	"interchange/internal/handler/proxy"
	"interchange/internal/middleware"
	"interchange/internal/router"
	"interchange/internal/service"
	"interchange/internal/service/audio"
	"interchange/internal/service/chat"
	"interchange/internal/service/embedding"
	"interchange/internal/service/images"
	"interchange/internal/service/models"
	"interchange/internal/telemetry"
)

import (
	_ "interchange/cmd/docs"
)

// Injectors from wire.go:

// wireApp init application.
func wireApp(configuration *config.Configuration, zapLogger *zap.Logger) (*App, func(), error) {
	trace, err := telemetry.NewTrace(configuration)
	if err != nil {
		return nil, nil, err
	}
	metric := telemetry.NewMetric(configuration)
	traceEntry := middleware.NewTraceEntry(trace, metric, configuration)
	fluentdClient, err := client.NewFluentdClient(zapLogger, configuration)
	if err != nil {
		return nil, nil, err
	}
	logRepository := repository.NewLogRepository(configuration, fluentdClient, trace)
	recovery := middleware.NewRecovery(zapLogger, trace, metric, configuration, logRepository)
	cors := middleware.NewCors(trace)
	middlewareLogger := middleware.NewLogger(zapLogger, trace, configuration, logRepository)
	response := middleware.NewResponse(zapLogger, trace, metric, configuration, logRepository)
	mongoClient, cleanup, err := client.NewMongoClient(zapLogger, configuration)
	if err != nil {
		return nil, nil, err
	}
	userRepository := repository2.NewUserRepository(trace, mongoClient)
	userService := service.NewUserService(trace, userRepository)
	adminUserHandler := handler.NewAdminUserHandler(trace, userService)
	userAPIKeyRepository := repository2.NewUserAPIKeyRepository(trace, mongoClient)
	redisClient, cleanup2, err := client.NewRedisClient(zapLogger, configuration)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	rateLimiterRepository := repository3.NewRateLimiterRepository(trace, redisClient)
	userAPIKeyService := service.NewUserAPIKeyService(trace, userRepository, userAPIKeyRepository, rateLimiterRepository, configuration, zapLogger)
	adminUserAPIKeyHandler := handler.NewAdminUserAPIKeyHandler(trace, userAPIKeyService, userService)
	adminUserAPIKeyRouter := router.NewAdminUserAPIKeyRouter(adminUserAPIKeyHandler)
	adminRouter := router.NewAdminRouter(adminUserHandler, adminUserAPIKeyRouter)
	httpClient := newHttpClient()
	chatService := chat.NewOpenAIService(trace, httpClient)
	imagesService := images.NewOpenAIService(trace, httpClient)
	audioService := audio.NewOpenAIService(trace, httpClient)
	embeddingService := embedding.NewOpenAIService(trace, httpClient)
	modelsService := models.NewOpenAIService(trace, httpClient)
	registry := service.ProvideRegistryWithServices(chatService, imagesService, audioService, embeddingService, modelsService)
	chatHandler := proxy.NewChatHandler(trace, registry, zapLogger, configuration, userAPIKeyService, logRepository)
	imageHandler := proxy.NewImageHandler(trace, registry, userAPIKeyService, zapLogger, configuration, logRepository)
	audioHandler := proxy.NewAudioHandler(trace, registry, zapLogger, configuration, userAPIKeyService, logRepository)
	embeddingHandler := proxy.NewEmbeddingHandler(trace, registry, rateLimiterRepository, userAPIKeyService, zapLogger, configuration, logRepository)
	modelsHandler := proxy.NewModelsHandler(trace, registry, rateLimiterRepository, userAPIKeyService, zapLogger)
	proxyService := service.NewProxyService(trace, httpClient)
	proxyHandler := handler.NewProxyHandler(trace, proxyService, userAPIKeyService, zapLogger, configuration, rateLimiterRepository, logRepository)
	apiKey := middleware.NewAPIKey(zapLogger, trace, metric, userAPIKeyService)
	rateLimit := middleware.NewRateLimit(trace, rateLimiterRepository, userAPIKeyService)
	user := middleware.NewUser(zapLogger, trace, metric, userService)
	proxyRouter := router.NewProxyRouter(chatHandler, imageHandler, audioHandler, embeddingHandler, modelsHandler, proxyHandler, apiKey, rateLimit, user)
	mcpRouter := router.NewMCPRouter(proxyHandler, apiKey, rateLimit, user)
	engine := router.NewRouter(configuration, traceEntry, recovery, cors, middlewareLogger, response, adminRouter, proxyRouter, mcpRouter)
	server := newHttpServer(configuration, engine)
	cronCron := cron.NewCron(zapLogger)
	app := newApp(configuration, zapLogger, server, cronCron)
	return app, func() {
		cleanup2()
		cleanup()
	}, nil
}

// wireCommand init application.
func wireCommand(configuration *config.Configuration, zapLogger *zap.Logger) (*command.Command, func(), error) {
	exampleHandler := command2.NewExampleHandler(zapLogger)
	commandCommand := command.NewCommand(exampleHandler)
	return commandCommand, func() {
	}, nil
}
